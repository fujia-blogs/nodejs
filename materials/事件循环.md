# 事件循环

> 基于 node.js 10+

1，事件循环原理和浏览器的原理是不同的，运行结果上两者是一致的，原理上：

- 一个是基于浏览器，浏览器的核心是宏任务和微任务
- 一个是基于 libuv 库，而且 node.js 还有阶段性任务执行阶段

2，**事件循环简单理解就是一个无限的 while 循环**

## 问答

1，谁来启动这个循环过程，循环条件是什么？

2，循环的是什么任务呢？

核心流程中需要的关注循环执行的是**poll 这个过程**

在 poll 过程中，主要处理异步 I/O 的回调函数以及其它的回调函数

异步 I/O 分为：网络 I/O 和文件 I/O

3，循环的任务是否存在优先级概念？

4，什么进程或线程来执行这个循环？

5，无限循环有没有终点？

当所有的微任务和宏任务都清空的时候，虽然当前没有任务可执⾏了，但是也并不能代表循环结束了。

因为可能存在当前还未回调的异步 I/O，所以这**个循环是没有终点的，只要进程在，并且有新的任务存在，就会去执⾏**。

6，node.js 事件循环发起点：

- node.js 启动后
- setTimeout 回调函数
- setInterval 回调函数
- 可能是一次 I/O 后的回调函数

7，主线程是否会被阻塞？

主线程会因为回调函数而阻塞

8，node.js 是单线程还是多线程？

**主线程是单线程执行的**，但是 node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件，而且还存在其它线程，包括：垃圾回收，内存优化等

- 主要还是主线程来循环遍历当前事件

## 循环原理

1，六个阶段

- timers
- pending callbacks
- idle,prepare
- poll

  - connections

- check
- close callbacks

2，timers

本阶段执行已被 setTimeout()和 setInterval()调度的回调函数，由这两个函数启动的回调函数

3，pending callbacks

执行某些系统操作的回调函数

4，idle, prepare：仅系统内部使用，知道即可

5，poll

检索新的 I/O 事件，执行与 I/O 相关的回调，其它情况 node.js 将在适当时在此阻塞

6，check

setImmediate()回调函数在这里执行，setImmediate 并不是立马执行而是当事件循环 poll 中没有新的事件处理时就执行该部分

7，close callbacks: 执行一些关闭的回调函数，如：socket.on('close', () => {})

### 主线程

1，核心的主线程，它的执行阶段主要处理三个核心逻辑：

- 执行同步代码
- 将异步任务插入到微任务队列或宏任务队列中
- 执⾏微任务或者宏任务的回调函数。在主线程处理回调函数的同时，也需要判断是否插⼊微任务和宏任务。根据优先级，先判断微任务队列是否存在任务，存在则先执⾏微任务，不存在则判断在宏任务队列是否有任务，有则执⾏

## 知识点

1，setTimeout 如果不设置时间或者设置时间为 0，则默认为 1ms

2，主流程执⾏完成后，超过 1ms 时，会将 setTimeout 回调函数逻辑插⼊到待执⾏回调函数 poll 队列中

3，由于当前 poll 队列中存在可执⾏回调函数，因此需要先执⾏完，待完全执⾏完成后，才会执⾏ check：setImmediate

**先执行回调，再执行 setImmediate**

4，⼀个⾮常关键点，当 Node.js 启动后，会初始化事件循环，处理已提供的输⼊脚本，它可能会先调⽤⼀些异步的 API、调度定时器，或者 process.nextTick()，然后再开始处理事件循环。

因此可以这样理解，**Node.js 进程启动后，就发起了⼀个新的事件循环，也就是事件循环的起点**

5，主线程会因为回调函数而阻塞

### 微任务

1，node.js 中微任务包含 2 种⸺process.nextTick 和 Promise。微任务在事件循环中优先级是最⾼的，因此在同⼀个事件循环中有其他任务存在时，优先执⾏微任务队列。

并且 process.nextTick 和 Promise 也存在优先级，**process.nextTick ⾼于 Promise。**

### 宏任务

1，在 Node.js 中宏任务包含 4 种⸺setTimeout、setInterval、setImmediate 和 I/O。

宏任务在微任务执⾏之后执⾏，因此在同⼀个事件循环周期内，如果既存在微任务队列⼜存在宏任务队列，那么**优先将微任务队列清空，再执⾏宏任务队列**。
