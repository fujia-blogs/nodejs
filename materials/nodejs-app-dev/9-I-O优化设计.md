# I/O 优化设计

1. I/O 不会影响整体 node.js 服务的性能，但是会因为 I/O 影响服务器系统，从而侧面影响到 node.js 性能。

## I/O 基础

1. I/O（Input/Output）意思是输⼊输出，其实就是数据传递的⼀个过程。

2. I/O 在系统层面的 2 个阶段：

- 第一个阶段是**读取文件，**将文件放入操作系统内核缓冲区。
- 第二个阶段是将**内核缓冲区拷贝到应用程序地址空间。**

### I/O 五种模型

1. 阻塞 I/O

例如读取⼀个⽂件，我们必须要等待⽂件读取完成后，也就是完成上⾯所说的两个阶段，才能执⾏其他逻辑，⽽当前是⽆法释放 CPU 的，因此⽆法去处理其他逻辑。

2. 非阻塞 I/O

⾮阻塞的意思是，我们发起了⼀个读取⽂件的指令，系统会返回正在处理中，然后这时候如果要释放进程中的 CPU 去处理其他逻辑，你就必须间隔⼀段时间，然后不停地去询问操作系统，使⽤轮询的判断⽅法看是否读取完成了。

3. 多路复用 I/O

这⼀模型主要是为了解决轮询调度的问题，我们可以将这些 I/O Socket 处理的结果统⼀交给⼀个独⽴线程来处理，当 I/O Socket 处理完成后，就主动告诉业务，处理完成了，这样不需要每个业务都来进⾏轮询查询了。

目前常见的三种类型：

- select

select 是⽐较旧的，它和 poll 的区别在于 poll 使⽤的是链表来保存 I/O Socket 数据，⽽ select 是数组，因此 select 会有上限 1024，⽽ poll 则没有。

- poll

- epoll

select、poll 与 epoll 的区别在于，前两者不会告诉你是哪个 I/O Socket 完成了，⽽ epoll 会通知具体哪个 I/O Socket 完成了哪个阶段的操作，这样就不需要去遍历查询了。

**tips: 一个重点是，这三者只会告知文件读取进入了进入了操作系统内核缓存区，即 i/O 在 OS 的第一个阶段，第二个阶段从内核拷贝到应用程序地址空间还是同步等待的。**

4. 信号驱动 I/O

这种模式和多路复⽤的区别在于不需要有其他线程来处理，⽽是在完成了读取进⼊操作系统内核缓冲区后，⽴⻢通知，也就是第⼀阶段可以由系统层⾯来处理，不需要独⽴线程来管理，但是第⼆阶段还是和多路复⽤⼀样。

5. 异步 I/O

和信号驱动不同的是，异步 I/O 是**两个阶段都完成了以后才会通知，**并不是第一个阶段完成。

常说的 Node.js 是⼀个异步 I/O 这个是没有错的。具体来说 Node.js 是其 libv 库⾃⾏实现的⼀种类似异步 I/O 的模型，对于 Node.js 应⽤来说是⼀个异步 I/O，因此⽆须处理两个过程，⽽在 libv 内部实现，则是多线程的⼀个 epoll 模型。这点是⾮常重要的，希望你可以牢记。

## 本地磁盘 I/O

1. 如果是写 I/O，并且不需要获取写⼊结果时，则不需要进⾏回调处理，减少主线程压⼒，⽐如最常⻅的例⼦就是写⽇志；

2. 如果是写 I/O，可以使⽤⽂件流的⽅式，避免重复的打开同⼀个⽂件，损耗不必要的打开和关闭⽂件的过程；

3. 如果是写 I/O，为了缓解写并发对系统的压⼒，可以将需要写⼊的⽇志放⼊⼀个临时内存中，从⽽降低系统并发处理压⼒，从⽽降低系统负载；

4. 如果是读 I/O，并且需要获取读取结果时，能够使⽤缓存尽量使⽤缓存，因为读 I/O 是需要时间，虽然不影响主线程性能，但是会影响⽤户响应时间，当读 I/O 过⼤，则系统压⼒较⼤，从⽽影响整体读接⼝的性能，因此需要使⽤缓存，减少并发对系统的 I/O 压⼒；

5. 如果是读 I/O，并且⽆法进⾏缓存的，则尽量考虑不使⽤本地磁盘 I/O 操作；

6. 如果是读 I/O，涉及⼤⽂件读取操作时，则应使⽤数据流的⽅式，⽽不是⼀次性读取内存中进⾏处理。

### 文件读取

1. 读取⼤⽂件，，⽐如说⼀次性读取⼀个 Excel 的⼤⽂件，然后对每⼀⾏进⾏处理，这时候如果使⽤ Node.js 的 fs 会导致性能问题，并且处理时间也会⾮常⻓，这部分应该尽量使⽤⽂件流⽅式。

### 日志模块

1. ⽇志存在很⼤的写情况，需要从这 3 个⽅⾯去提升性能：

- 保存待写⼊的⽇志信息，当超出最⼤保存⽇志条数时，则直接写⼊，不保存在⽇志信息中，主要是避免内存过⼤，引起垃圾回收性能问题；
- 定时从临时缓存中，取出数据写⼊⽂件中；
- 写⼊⽂件后，⽆须处理回调。

## 网络 I/O

1. 在后台服务中常见的网络 I/O 的类型：

- 缓存型，如：MemCache, Redis
- 数据存储型，如：MySQL，MongoDB
- 服务型，如：内网 API 服务或第三方 API。

2. ⽹络 I/O 的成本是最⾼的，因为会涉及两个最重要的点：

- 依赖其它服务的性能
- 依赖服务器之间的延时。

3. 优化的策略：

- 减少与⽹络 I/O 的交互，⽐如缓存已获取的内容；
- 使⽤更⾼性能的⽹络 I/O 替代其他性能较差的、成本更⾼的⽹络 I/O 类型，⽐如数据库读写的 I/O 成本是明显⾼于缓存型的，因此可以使⽤缓存型⽹络 I/O 替换存储型；
- 降低目标网络 I/O 服务的并发压力，采用异步队列的方式。

### 减少网络 I/O

1. 本地缓存对于这种固定化，并且⽆⽤户差别的数据是可以进⾏缓存的，⽽且⾮常有必要。⽐如说，我们常⻅的⼀些客户端配置化信息。

2. 本地内存缓存有⼀个最⼤的问题点在于，每台机器可能缓存了不同的数据，⽐如每台机器缓存了运营配置，这时候运营修改了配置，不同机器过期时间不⼀致，导致⽤户每次刷新可能出现不同的⾸⻚配置。那么这个问题就需要⾼性能替换⽅案（共享内存⽅案）来解决了。

### 高性能替换

1. 本地缓存是直接本地内存，性能⾼过共享内存，也就是⽹络 I/O 中的共享内存⽅式，但是⽹络 I/O 共享内存的性能⾼于⽹络 I/O 中的磁盘 I/O 性能。⽐如 Redis 的性能是远⾼于 MySQL 的，主要有⼀点是前两者是共享内存的⽅式，内存的操作是快于磁盘 I/O。因此可以通过 MySQL 获取数据后保存在⾼性能⽹络 I/O 的 Redis 上，这样可以⼤⼤提升性能。其次共享内存⽅案也可以解决本地缓存中数据不⼀致的问题。

2. 共享内存适合：可以延迟更新的数据服务，丙炔与用户维度无关，每个用户(或者有限用户分类)拉取的内容都是一致的。如果每个⽤户内容不⼀致，会导致缓存命中较低，同时浪费⼤量的内存空间。

### 异步队列

1. 用户发送请求后，只告知用户，你已经进入队列，但是真正的情况是**用户的请求会缓存在一个队列中，**再一个个前往具体的网络 I/O 服务中，独立去处理，这时候并发压⼒就可控，因此也不会出现性能问题。

2. 异步队列是一种比较高性能的网络 I/O，通过一个高性能网络 I/O 将其它业务逻辑封装，让用户感知，只是**延迟了用户收到结果的时间。**

3. 异步队列可以使用 kafka,MQ 等。

## 要点

1. node.js 应用层是一个异步 I/O 模型，但是底层 libv 库是一个基于 epoll 的 I/O 模型。
